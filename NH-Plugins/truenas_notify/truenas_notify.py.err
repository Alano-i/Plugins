import os
import json
import time
import ssl
import threading
import logging
import datetime
import re
import ast
from fastapi import APIRouter
from fastapi.responses import FileResponse
from notifyhub.controller.server import server
from notifyhub.plugins.common import after_setup
from notifyhub.plugins.utils import get_plugin_data, get_plugin_config

import websocket

logger = logging.getLogger(__name__)

plugin_id = "truenas_notify"
plugin_name = "TrueNAS 通知"
plugins_name = f"「{plugin_name}」"
plugins_path = '/data/plugins/truenas_notify'

# ---------------- 配置获取 ----------------
data = get_plugin_data(plugin_id)
config = get_plugin_config(plugin_id)

truenas_server = config.get('truenas_server')
api_key = config.get('api_key')
notify_switch = config.get('notify_switch', True)
bind_channel = config.get('bind_channel')

pic_url_base = f"https://raw.githubusercontent.com/Alano-i/Plugins/refs/heads/main/TrueNas_notify/img"
if server.site_url:
    pic_url_base = f"{server.site_url}/api/plugins/{plugin_id}/cover"
else:
    logger.error(f"{plugins_name}未配置站点外网访问地址，请前往系统设置 -> 网络设置 -> 站点访问地址配置")

logging.getLogger("websocket").setLevel(logging.WARNING)

logger.info(f"{plugins_name}监控的TrueNAS服务器地址：{truenas_server}")
logger.info(f"{plugins_name}封面图 URL 前缀：{pic_url_base}")

# ---------------- WebSocket 全局变量 ----------------
ws = None
is_running = False
lock = threading.Lock()
RECONNECT_INTERVAL = 15  # 秒

# ---------------- 工具函数 ----------------
def convert_seconds_to_mmss(seconds):
    seconds = int(seconds)
    return "{:02d} 分 {:02d} 秒".format(seconds // 60, seconds % 60)

# ---------------- progress_*_text 函数 ----------------
def progress_device_text(alert_type, text):
    patterns = {
        r"Device: (/dev/sd[a-z]+) \[SAT\], ATA error count increased from (\d+) to (\d+)":
            "设备: {0}, ATA 错误计数从{1}增加到{2}",
        r"Device: (/dev/sd[a-z]+) \[SAT\], (\d+) Currently unreadable \(pending\) sectors\.":
            "设备: {0}, {1}个扇区当前无法读取（挂起）"
    }
    for pattern, fmt in patterns.items():
        match = re.search(pattern, text)
        if match:
            return fmt.format(*match.groups())
    return text

def progress_app_text(alert_type, text):
    patterns = {
        r'An update is available for ["\'](.+?)["\'] application.+':
            "{0} 有更新",
        r"Failed to sync (.+?) catalog:(.+)":
            "同步 {0} 目录失败，原因：\n{1}"
    }
    for pattern, fmt in patterns.items():
        match = re.search(pattern, text)
        if match:
            return fmt.format(*match.groups())
    return text

def progress_scrub_text(alert_type, text):
    logger.error(f'alert_text进入函数前：{text}')
    pattern = r"Scrub of pool '(.+)' (started|finished)\."
    match = re.search(pattern, text)
    if match:
        pool_name = match.group(1)
        status = {"started": "检查开始", "finished": "检查完成"}.get(match.group(2), "检查状态未知")
        result = f"存储池 '{pool_name}' {status}"
    else:
        result = text
    logger.error(f'alert_text处理后：{result}')
    return result

def progress_ups_text(alert_type, text):
    if alert_type == 'UPSCommbad':
        return '与 UPS 通信丢失，无法获取电池数据'
    battery_charge = re.search(r"battery\.charge:\s*(\d+)", text)
    battery_charge_low = re.search(r"battery\.charge\.low:\s*(\d+)", text)
    battery_runtime = re.search(r"battery\.runtime:\s*(\d+)", text)
    battery_runtime_low = re.search(r"battery\.runtime\.low:\s*(\d+)", text)
    return f"电池总电量：{battery_charge.group(1)}%\n电池可运行：{convert_seconds_to_mmss(battery_runtime.group(1))}\n低电量模式临界电量：{battery_charge_low.group(1)}%\n低电量模式等待时间：{battery_runtime_low.group(1)}秒"

def progress_space_text(alert_type, text):
    patterns = {
        r'Space usage for pool (["\'])(.+)\1 is (\d+)%\. Optimal pool performance requires used space remain below 80%\.':
            'ZFS 存储池 "{1}" 的空间使用达到 {2}%. 为保证最佳池性能，使用空间应保持在 80% 以下.',
        r"Failed to check for alert ZpoolCapacity:(.+)":
            "检查存储池容量失败，原因：\n{0}"
    }
    for pattern, fmt in patterns.items():
        match = re.search(pattern, text)
        if match:
            return fmt.format(*match.groups())
    return text

def progress_ntp_text(alert_type, text):
    pattern = r"NTP health check failed - No Active NTP peers: (\[.*\])"
    match = re.search(pattern, text)
    if match:
        peers = ast.literal_eval(match.group(1))
        try:
            ip_list = [list(peer.keys())[0] for peer in peers]
            return "NTP 健康检查失败，以下 NTP 无法连接：\n" + ", ".join(ip_list)
        except:
            return text.replace("NTP health check failed - No Active NTP peers:", "NTP 健康检查失败 - 无活动 NTP 服务器")
    return text

def progress_text(alert_type, alert_text):
    handlers_type = {
        'ScrubFinished': progress_scrub_text,
        'ScrubStarted': progress_scrub_text,
        'ZpoolCapacityNotice': progress_space_text,
        'ZpoolCapacityWarning': progress_space_text,
        'NTPHealthCheck': progress_ntp_text,
        'ChartReleaseUpdate': progress_app_text,
        'CatalogSyncFailed': progress_app_text,
        'SMART': progress_device_text,
        'UPSOnline': progress_ups_text,
        'UPSOnBattery': progress_ups_text,
        'UPSCommbad': progress_ups_text,
    }
    logger.error(f'alert_text处理前：{alert_text}')
    if alert_type in handlers_type:
        alert_text = handlers_type[alert_type](alert_type, alert_text)
    logger.error(f'alert_text处理后：{alert_text}')
    return alert_text

# ---------------- 消息发送 ----------------
def push_msg(msg_title, msg_digest, pic_url):
    if notify_switch:
        try:
            server.send_notify_by_channel(channel_name=bind_channel, title=msg_title, content=msg_digest, push_img_url=pic_url)
            logger.info(f"{plugins_name} ✅ 已发送通知")
        except Exception as e:
            logger.error(f"{plugins_name} ❌ 发送通知失败: {e}")
    else:
        logger.info(f"{plugins_name} 通知开关未开启，跳过发送通知")

# ---------------- alert 处理 ----------------
def progress_alert_text(alert):
    alert_level = alert['level']
    alert_type = alert['klass']
    alert_text = alert['formatted']
    alert_time = datetime.datetime.fromtimestamp(alert['datetime']['$date']/1000).strftime("%Y-%m-%d %H:%M:%S")

    level_list = {'CRITICAL':'‼️','WARNING':'⚠️','NOTICE':'✉️','INFO':'ℹ️'}
    alert_mapping = {
        'ScrubFinished': {'title': '磁盘检修完成','pic':'scrub.png'},
        'ScrubStarted': {'title':'磁盘检修开始','pic':'scrub.png'},
        'ZpoolCapacityNotice': {'title':'存储池容量提醒','pic':'space.png'},
        'ZpoolCapacityWarning': {'title':'存储池容量警告','pic':'space.png'},
        'NTPHealthCheck': {'title':'NTP 健康检查','pic':'ntp.png'},
        'UPSOnline': {'title':'UPS 恢复供电','pic':'ups_on.png'},
        'UPSOnBattery': {'title':'UPS 进入电池供电','pic':'ups_battery.png'},
        'UPSCommbad': {'title':'UPS 断开连接','pic':'ups_lost.png'},
        'ChartReleaseUpdate': {'title':'应用有更新','pic':'update.png'},
        'CatalogSyncFailed': {'title':'应用目录同步失败','pic':'update.png'},
        'SMART': {'title':'SMART异常','pic':'smart.png'},
        'AlertSourceRunFailed': {'title':'警报源运行失败','pic':'default.png'},
    }

    new_alert_type = alert_type
    new_alert_info = alert_mapping.get(new_alert_type, {})
    pic_url = f"{pic_url_base}/{new_alert_info.get('pic','default.png')}"
    msg_title = f"{level_list.get(alert_level, alert_level)} {new_alert_info.get('title', new_alert_type)}"
    alert_text = progress_text(new_alert_type, alert_text)
    msg_digest = f"{alert_text}\n{alert_time}"
    logger.info(f"{plugins_name} 获取到系统新通知:\n{msg_title}\n{msg_digest}")
    push_msg(msg_title, msg_digest, pic_url)

# ---------------- WebSocket ----------------
def on_ws_open(ws):
    ws.send(json.dumps({"msg":"connect","version":"1","support":["1"]}))
    threading.Thread(target=send_heartbeat, args=(ws,), daemon=True).start()

def on_ws_message(ws, message):
    global session_id
    json_data = json.loads(message)
    if json_data['msg']=='connected':
        session_id=json_data['session']
        ws.send(json.dumps({"id":session_id,"msg":"method","method":"auth.login_with_api_key","params":[api_key]}))
    elif json_data['msg']=='result' and json_data.get('result')=='pong':
        logger.info(f"{plugins_name} 心跳成功: {json_data}")
    elif json_data['msg']=='result' and json_data.get('result')==True:
        ws.send(json.dumps({"msg":"sub","id":session_id,"name":"alert.list"}))
    elif json_data['msg']=='added' and json_data['collection']=='alert.list':
        alert = json_data['fields']
        progress_alert_text(alert)

def on_ws_error(ws, error):
    logger.error(f"{plugins_name} 连接 WebSocket 出错: {error}")
    auto_reconnect_scheduler()

def on_ws_close(ws, close_status_code, close_msg):
    logger.info(f"{plugins_name} WebSocket关闭，code:{close_status_code}, msg:{close_msg}")
    auto_reconnect_scheduler()

def get_truenas_alert():
    global ws
    try:
        websocket_url = f"{truenas_server}/websocket"
        # logger.info(f"{plugins_name} get_truenas_alert() 被调用, URL={websocket_url}")
        
        ws = websocket.WebSocketApp(
            websocket_url,
            on_open=on_ws_open,
            on_message=on_ws_message,
            on_error=on_ws_error,
            on_close=on_ws_close
        )
        # logger.info(f"{plugins_name} ws 实例创建完成, 准备调用 run_forever()")
        logger.info(f"{plugins_name} WebSocket 实例创建完成")
        
        ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE})
        logger.warning(f"{plugins_name} ws.run_forever() 退出了, 将触发重连")
        auto_reconnect_scheduler()

    except Exception as e:
        logger.error(f"{plugins_name} 启动 WebSocket 异常: {e}")
        auto_reconnect_scheduler()

def auto_reconnect_scheduler():
    global is_running
    with lock:
        # logger.info(f"{plugins_name} auto_reconnect_scheduler() 被调用, is_running={is_running}")
        if not is_running:
            is_running = True

            def reconnect():
                global is_running
                logger.info(f"{plugins_name} ⏳ {RECONNECT_INTERVAL} 秒后开始重连...")
                time.sleep(RECONNECT_INTERVAL)
                logger.info(f"{plugins_name} 🚀 开始执行重连任务 (新线程)")
                get_truenas_alert()
                is_running = False

            threading.Thread(target=reconnect, daemon=True).start()
        else:
            logger.info(f"{plugins_name} 已有 WebSocket 线程在运行, 跳过重连")

def send_heartbeat(ws):
    while True:
        try:
            ws.send(json.dumps({"id":"heartbeat-ping-pong","msg":"method","method":"core.ping"}))
        except Exception as e:
            logger.error(f"{plugins_name} 心跳异常: {e}")
            auto_reconnect_scheduler()
            break
        time.sleep(300)

# threading.Thread(target=auto_reconnect_scheduler, daemon=True).start()

# 在 after_setup 中注册定时任务（同步）
@after_setup(plugin_id=plugin_id, desc="TrueNAS 通知")
def setup_jobs():
    logger.info(f"{plugins_name} 启动 TrueNAS WebSocket 线程")
    threading.Thread(target=get_truenas_alert, daemon=True, name="TrueNAS_WS").start()

# ---------------- API ----------------
truenas_notify_router = APIRouter(prefix="/truenas_notify", tags=["truenas_notify"])

@truenas_notify_router.get("/cover/{filename}")
async def cover(filename: str):
    file_path = os.path.join(plugins_path, 'cover', filename)
    logger.info(f"{plugins_name} 请求图片: {file_path}")
    if os.path.exists(file_path) and os.path.isfile(file_path):
        ext = os.path.splitext(filename)[-1].lower()
        media_type = {".jpg":"image/jpeg",".jpeg":"image/jpeg",".png":"image/png",".gif":"image/gif"}.get(ext,"application/octet-stream")
        response = FileResponse(file_path, media_type=media_type)
        response.headers["Cache-Control"]="public, max-age=604800"
        return response
    else: 
        return {"error": "Image not found"}
