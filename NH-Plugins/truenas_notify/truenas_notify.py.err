import os
import json
import time
import ssl
import threading
import logging
import datetime
import re
import ast
from fastapi import APIRouter
from fastapi.responses import FileResponse
from notifyhub.controller.server import server
from notifyhub.plugins.common import after_setup
from notifyhub.plugins.utils import get_plugin_data, get_plugin_config

import websocket

logger = logging.getLogger(__name__)

plugin_id = "truenas_notify"
plugin_name = "TrueNAS é€šçŸ¥"
plugins_name = f"ã€Œ{plugin_name}ã€"
plugins_path = '/data/plugins/truenas_notify'

# ---------------- é…ç½®è·å– ----------------
data = get_plugin_data(plugin_id)
config = get_plugin_config(plugin_id)

truenas_server = config.get('truenas_server')
api_key = config.get('api_key')
notify_switch = config.get('notify_switch', True)
bind_channel = config.get('bind_channel')

pic_url_base = f"https://raw.githubusercontent.com/Alano-i/Plugins/refs/heads/main/TrueNas_notify/img"
if server.site_url:
    pic_url_base = f"{server.site_url}/api/plugins/{plugin_id}/cover"
else:
    logger.error(f"{plugins_name}æœªé…ç½®ç«™ç‚¹å¤–ç½‘è®¿é—®åœ°å€ï¼Œè¯·å‰å¾€ç³»ç»Ÿè®¾ç½® -> ç½‘ç»œè®¾ç½® -> ç«™ç‚¹è®¿é—®åœ°å€é…ç½®")

logging.getLogger("websocket").setLevel(logging.WARNING)

logger.info(f"{plugins_name}ç›‘æ§çš„TrueNASæœåŠ¡å™¨åœ°å€ï¼š{truenas_server}")
logger.info(f"{plugins_name}å°é¢å›¾ URL å‰ç¼€ï¼š{pic_url_base}")

# ---------------- WebSocket å…¨å±€å˜é‡ ----------------
ws = None
is_running = False
lock = threading.Lock()
RECONNECT_INTERVAL = 15  # ç§’

# ---------------- å·¥å…·å‡½æ•° ----------------
def convert_seconds_to_mmss(seconds):
    seconds = int(seconds)
    return "{:02d} åˆ† {:02d} ç§’".format(seconds // 60, seconds % 60)

# ---------------- progress_*_text å‡½æ•° ----------------
def progress_device_text(alert_type, text):
    patterns = {
        r"Device: (/dev/sd[a-z]+) \[SAT\], ATA error count increased from (\d+) to (\d+)":
            "è®¾å¤‡: {0}, ATA é”™è¯¯è®¡æ•°ä»{1}å¢åŠ åˆ°{2}",
        r"Device: (/dev/sd[a-z]+) \[SAT\], (\d+) Currently unreadable \(pending\) sectors\.":
            "è®¾å¤‡: {0}, {1}ä¸ªæ‰‡åŒºå½“å‰æ— æ³•è¯»å–ï¼ˆæŒ‚èµ·ï¼‰"
    }
    for pattern, fmt in patterns.items():
        match = re.search(pattern, text)
        if match:
            return fmt.format(*match.groups())
    return text

def progress_app_text(alert_type, text):
    patterns = {
        r'An update is available for ["\'](.+?)["\'] application.+':
            "{0} æœ‰æ›´æ–°",
        r"Failed to sync (.+?) catalog:(.+)":
            "åŒæ­¥ {0} ç›®å½•å¤±è´¥ï¼ŒåŸå› ï¼š\n{1}"
    }
    for pattern, fmt in patterns.items():
        match = re.search(pattern, text)
        if match:
            return fmt.format(*match.groups())
    return text

def progress_scrub_text(alert_type, text):
    logger.error(f'alert_textè¿›å…¥å‡½æ•°å‰ï¼š{text}')
    pattern = r"Scrub of pool '(.+)' (started|finished)\."
    match = re.search(pattern, text)
    if match:
        pool_name = match.group(1)
        status = {"started": "æ£€æŸ¥å¼€å§‹", "finished": "æ£€æŸ¥å®Œæˆ"}.get(match.group(2), "æ£€æŸ¥çŠ¶æ€æœªçŸ¥")
        result = f"å­˜å‚¨æ±  '{pool_name}' {status}"
    else:
        result = text
    logger.error(f'alert_textå¤„ç†åï¼š{result}')
    return result

def progress_ups_text(alert_type, text):
    if alert_type == 'UPSCommbad':
        return 'ä¸ UPS é€šä¿¡ä¸¢å¤±ï¼Œæ— æ³•è·å–ç”µæ± æ•°æ®'
    battery_charge = re.search(r"battery\.charge:\s*(\d+)", text)
    battery_charge_low = re.search(r"battery\.charge\.low:\s*(\d+)", text)
    battery_runtime = re.search(r"battery\.runtime:\s*(\d+)", text)
    battery_runtime_low = re.search(r"battery\.runtime\.low:\s*(\d+)", text)
    return f"ç”µæ± æ€»ç”µé‡ï¼š{battery_charge.group(1)}%\nç”µæ± å¯è¿è¡Œï¼š{convert_seconds_to_mmss(battery_runtime.group(1))}\nä½ç”µé‡æ¨¡å¼ä¸´ç•Œç”µé‡ï¼š{battery_charge_low.group(1)}%\nä½ç”µé‡æ¨¡å¼ç­‰å¾…æ—¶é—´ï¼š{battery_runtime_low.group(1)}ç§’"

def progress_space_text(alert_type, text):
    patterns = {
        r'Space usage for pool (["\'])(.+)\1 is (\d+)%\. Optimal pool performance requires used space remain below 80%\.':
            'ZFS å­˜å‚¨æ±  "{1}" çš„ç©ºé—´ä½¿ç”¨è¾¾åˆ° {2}%. ä¸ºä¿è¯æœ€ä½³æ± æ€§èƒ½ï¼Œä½¿ç”¨ç©ºé—´åº”ä¿æŒåœ¨ 80% ä»¥ä¸‹.',
        r"Failed to check for alert ZpoolCapacity:(.+)":
            "æ£€æŸ¥å­˜å‚¨æ± å®¹é‡å¤±è´¥ï¼ŒåŸå› ï¼š\n{0}"
    }
    for pattern, fmt in patterns.items():
        match = re.search(pattern, text)
        if match:
            return fmt.format(*match.groups())
    return text

def progress_ntp_text(alert_type, text):
    pattern = r"NTP health check failed - No Active NTP peers: (\[.*\])"
    match = re.search(pattern, text)
    if match:
        peers = ast.literal_eval(match.group(1))
        try:
            ip_list = [list(peer.keys())[0] for peer in peers]
            return "NTP å¥åº·æ£€æŸ¥å¤±è´¥ï¼Œä»¥ä¸‹ NTP æ— æ³•è¿æ¥ï¼š\n" + ", ".join(ip_list)
        except:
            return text.replace("NTP health check failed - No Active NTP peers:", "NTP å¥åº·æ£€æŸ¥å¤±è´¥ - æ— æ´»åŠ¨ NTP æœåŠ¡å™¨")
    return text

def progress_text(alert_type, alert_text):
    handlers_type = {
        'ScrubFinished': progress_scrub_text,
        'ScrubStarted': progress_scrub_text,
        'ZpoolCapacityNotice': progress_space_text,
        'ZpoolCapacityWarning': progress_space_text,
        'NTPHealthCheck': progress_ntp_text,
        'ChartReleaseUpdate': progress_app_text,
        'CatalogSyncFailed': progress_app_text,
        'SMART': progress_device_text,
        'UPSOnline': progress_ups_text,
        'UPSOnBattery': progress_ups_text,
        'UPSCommbad': progress_ups_text,
    }
    logger.error(f'alert_textå¤„ç†å‰ï¼š{alert_text}')
    if alert_type in handlers_type:
        alert_text = handlers_type[alert_type](alert_type, alert_text)
    logger.error(f'alert_textå¤„ç†åï¼š{alert_text}')
    return alert_text

# ---------------- æ¶ˆæ¯å‘é€ ----------------
def push_msg(msg_title, msg_digest, pic_url):
    if notify_switch:
        try:
            server.send_notify_by_channel(channel_name=bind_channel, title=msg_title, content=msg_digest, push_img_url=pic_url)
            logger.info(f"{plugins_name} âœ… å·²å‘é€é€šçŸ¥")
        except Exception as e:
            logger.error(f"{plugins_name} âŒ å‘é€é€šçŸ¥å¤±è´¥: {e}")
    else:
        logger.info(f"{plugins_name} é€šçŸ¥å¼€å…³æœªå¼€å¯ï¼Œè·³è¿‡å‘é€é€šçŸ¥")

# ---------------- alert å¤„ç† ----------------
def progress_alert_text(alert):
    alert_level = alert['level']
    alert_type = alert['klass']
    alert_text = alert['formatted']
    alert_time = datetime.datetime.fromtimestamp(alert['datetime']['$date']/1000).strftime("%Y-%m-%d %H:%M:%S")

    level_list = {'CRITICAL':'â€¼ï¸','WARNING':'âš ï¸','NOTICE':'âœ‰ï¸','INFO':'â„¹ï¸'}
    alert_mapping = {
        'ScrubFinished': {'title': 'ç£ç›˜æ£€ä¿®å®Œæˆ','pic':'scrub.png'},
        'ScrubStarted': {'title':'ç£ç›˜æ£€ä¿®å¼€å§‹','pic':'scrub.png'},
        'ZpoolCapacityNotice': {'title':'å­˜å‚¨æ± å®¹é‡æé†’','pic':'space.png'},
        'ZpoolCapacityWarning': {'title':'å­˜å‚¨æ± å®¹é‡è­¦å‘Š','pic':'space.png'},
        'NTPHealthCheck': {'title':'NTP å¥åº·æ£€æŸ¥','pic':'ntp.png'},
        'UPSOnline': {'title':'UPS æ¢å¤ä¾›ç”µ','pic':'ups_on.png'},
        'UPSOnBattery': {'title':'UPS è¿›å…¥ç”µæ± ä¾›ç”µ','pic':'ups_battery.png'},
        'UPSCommbad': {'title':'UPS æ–­å¼€è¿æ¥','pic':'ups_lost.png'},
        'ChartReleaseUpdate': {'title':'åº”ç”¨æœ‰æ›´æ–°','pic':'update.png'},
        'CatalogSyncFailed': {'title':'åº”ç”¨ç›®å½•åŒæ­¥å¤±è´¥','pic':'update.png'},
        'SMART': {'title':'SMARTå¼‚å¸¸','pic':'smart.png'},
        'AlertSourceRunFailed': {'title':'è­¦æŠ¥æºè¿è¡Œå¤±è´¥','pic':'default.png'},
    }

    new_alert_type = alert_type
    new_alert_info = alert_mapping.get(new_alert_type, {})
    pic_url = f"{pic_url_base}/{new_alert_info.get('pic','default.png')}"
    msg_title = f"{level_list.get(alert_level, alert_level)} {new_alert_info.get('title', new_alert_type)}"
    alert_text = progress_text(new_alert_type, alert_text)
    msg_digest = f"{alert_text}\n{alert_time}"
    logger.info(f"{plugins_name} è·å–åˆ°ç³»ç»Ÿæ–°é€šçŸ¥:\n{msg_title}\n{msg_digest}")
    push_msg(msg_title, msg_digest, pic_url)

# ---------------- WebSocket ----------------
def on_ws_open(ws):
    ws.send(json.dumps({"msg":"connect","version":"1","support":["1"]}))
    threading.Thread(target=send_heartbeat, args=(ws,), daemon=True).start()

def on_ws_message(ws, message):
    global session_id
    json_data = json.loads(message)
    if json_data['msg']=='connected':
        session_id=json_data['session']
        ws.send(json.dumps({"id":session_id,"msg":"method","method":"auth.login_with_api_key","params":[api_key]}))
    elif json_data['msg']=='result' and json_data.get('result')=='pong':
        logger.info(f"{plugins_name} å¿ƒè·³æˆåŠŸ: {json_data}")
    elif json_data['msg']=='result' and json_data.get('result')==True:
        ws.send(json.dumps({"msg":"sub","id":session_id,"name":"alert.list"}))
    elif json_data['msg']=='added' and json_data['collection']=='alert.list':
        alert = json_data['fields']
        progress_alert_text(alert)

def on_ws_error(ws, error):
    logger.error(f"{plugins_name} è¿æ¥ WebSocket å‡ºé”™: {error}")
    auto_reconnect_scheduler()

def on_ws_close(ws, close_status_code, close_msg):
    logger.info(f"{plugins_name} WebSocketå…³é—­ï¼Œcode:{close_status_code}, msg:{close_msg}")
    auto_reconnect_scheduler()

def get_truenas_alert():
    global ws
    try:
        websocket_url = f"{truenas_server}/websocket"
        # logger.info(f"{plugins_name} get_truenas_alert() è¢«è°ƒç”¨, URL={websocket_url}")
        
        ws = websocket.WebSocketApp(
            websocket_url,
            on_open=on_ws_open,
            on_message=on_ws_message,
            on_error=on_ws_error,
            on_close=on_ws_close
        )
        # logger.info(f"{plugins_name} ws å®ä¾‹åˆ›å»ºå®Œæˆ, å‡†å¤‡è°ƒç”¨ run_forever()")
        logger.info(f"{plugins_name} WebSocket å®ä¾‹åˆ›å»ºå®Œæˆ")
        
        ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE})
        logger.warning(f"{plugins_name} ws.run_forever() é€€å‡ºäº†, å°†è§¦å‘é‡è¿")
        auto_reconnect_scheduler()

    except Exception as e:
        logger.error(f"{plugins_name} å¯åŠ¨ WebSocket å¼‚å¸¸: {e}")
        auto_reconnect_scheduler()

def auto_reconnect_scheduler():
    global is_running
    with lock:
        # logger.info(f"{plugins_name} auto_reconnect_scheduler() è¢«è°ƒç”¨, is_running={is_running}")
        if not is_running:
            is_running = True

            def reconnect():
                global is_running
                logger.info(f"{plugins_name} â³ {RECONNECT_INTERVAL} ç§’åå¼€å§‹é‡è¿...")
                time.sleep(RECONNECT_INTERVAL)
                logger.info(f"{plugins_name} ğŸš€ å¼€å§‹æ‰§è¡Œé‡è¿ä»»åŠ¡ (æ–°çº¿ç¨‹)")
                get_truenas_alert()
                is_running = False

            threading.Thread(target=reconnect, daemon=True).start()
        else:
            logger.info(f"{plugins_name} å·²æœ‰ WebSocket çº¿ç¨‹åœ¨è¿è¡Œ, è·³è¿‡é‡è¿")

def send_heartbeat(ws):
    while True:
        try:
            ws.send(json.dumps({"id":"heartbeat-ping-pong","msg":"method","method":"core.ping"}))
        except Exception as e:
            logger.error(f"{plugins_name} å¿ƒè·³å¼‚å¸¸: {e}")
            auto_reconnect_scheduler()
            break
        time.sleep(300)

# threading.Thread(target=auto_reconnect_scheduler, daemon=True).start()

# åœ¨ after_setup ä¸­æ³¨å†Œå®šæ—¶ä»»åŠ¡ï¼ˆåŒæ­¥ï¼‰
@after_setup(plugin_id=plugin_id, desc="TrueNAS é€šçŸ¥")
def setup_jobs():
    logger.info(f"{plugins_name} å¯åŠ¨ TrueNAS WebSocket çº¿ç¨‹")
    threading.Thread(target=get_truenas_alert, daemon=True, name="TrueNAS_WS").start()

# ---------------- API ----------------
truenas_notify_router = APIRouter(prefix="/truenas_notify", tags=["truenas_notify"])

@truenas_notify_router.get("/cover/{filename}")
async def cover(filename: str):
    file_path = os.path.join(plugins_path, 'cover', filename)
    logger.info(f"{plugins_name} è¯·æ±‚å›¾ç‰‡: {file_path}")
    if os.path.exists(file_path) and os.path.isfile(file_path):
        ext = os.path.splitext(filename)[-1].lower()
        media_type = {".jpg":"image/jpeg",".jpeg":"image/jpeg",".png":"image/png",".gif":"image/gif"}.get(ext,"application/octet-stream")
        response = FileResponse(file_path, media_type=media_type)
        response.headers["Cache-Control"]="public, max-age=604800"
        return response
    else: 
        return {"error": "Image not found"}
